@* Reusable component that allows user to choose album(s) or a folder to add selected item(s) to. *@
@inherits ToggleableComponent

<link href="css/Components/Modal/CollectionSelector.css" rel="stylesheet"/>

<ModalBackground Visibility="@Visibility">
    <div id="collection-selector">
        <div>
            <span>Add to</span>
            <div>
                <IconButton Icon="close" OnClick="@CloseBtnClick"/>
                <IconButton Icon="check" OnClick="@ConfirmBtnClick"/>
            </div>
        </div>

        <CollectionCreator @ref="@collectionCreator" Collections="@(Albums.Concat(Folders).ToList())" OnCollectionCreate="@SelectNewCollection"/>

        <div id="collection-groups">
            <IconButton Icon="history" OnClick="@(() => PreviousSelectionBtnClick(false))" Title="Restore the last selection of collections."/>

            <div class="hidden-buttons">
                @for (int i = 1; i < 6; i++)
                {
                    int ii = i;
                    <IconButton Icon="save" EventArgsOnClick="@(mouseEventArgs => SaveBtnClick(ii, mouseEventArgs))" Title="Ctrl click to save; click to apply."/>
                }
            </div>
        </div>
        
        <div id="collections-search">
            <TextInput @bind-Input="@searchText" Placeholder="Search Collections"/>
            <IconButton Icon="clear" OnClick="@(() => { searchText = ""; StateHasChanged(); })"/>
        </div>

        <div id="collections">
            <span>Albums</span>
            <div>
                @for (int i = 0; i < Albums.Count; i++)
                {
                    if (!String.IsNullOrWhiteSpace(searchText) && Albums[i].Name.IndexOf(searchText, StringComparison.InvariantCultureIgnoreCase) == -1) continue;

                    int ii = i;
                    <div class="collection" @onclick="@(() => AlbumClicked(ii))">
                        <div class="cover">
                            @if (!String.IsNullOrWhiteSpace(Albums[i].Cover))
                            {
                                <img src="mm_library/@Albums[i].Cover" alt=""/>
                            }
                        </div>
                        <Checkbox @bind-Input="@checkedAlbums[ii]" Label="@Albums[i].Name"/>
                    </div>
                }
            </div>

            <span>Folders</span>
            <div>
                @for (int i = 0; i < Folders.Count; i++)
                {
                    if (!String.IsNullOrWhiteSpace(searchText) && Folders[i].Name.IndexOf(searchText, StringComparison.InvariantCultureIgnoreCase) == -1) continue;

                    int ii = i;
                    <div class="collection" @onclick="@(() => FolderClicked(ii))">
                        <div class="cover">
                            @if (!String.IsNullOrWhiteSpace(Folders[i].Cover))
                            {
                                <img src="mm_library/@Folders[i].Cover" alt=""/>
                            }
                        </div>
                        <Checkbox @bind-Input="@checkedFolders[ii]" Label="@Folders[i].Name"/>
                    </div>
                }
            </div>
        </div>
    </div>
</ModalBackground>

<KeyboardShortcuts AltC="@Toggle"/>

@code {
    public List<Collection> Albums { get; private set; } = null!;
    public List<Collection> Folders { get; private set; } = null!;
    
    private List<bool> checkedAlbums = null!;
    private List<bool> checkedFolders = null!;
    public int CheckedFolderIndex { get; private set; } = -1; //Which index in Folders is checked (can only have 1 checked).

    private string? searchText;

    private CollectionCreator collectionCreator = null!;

    [Parameter, EditorRequired] public HashSet<Guid> SelectedItems { get; set; } = null!;
    
    [Parameter] public Action? Rerender { get; set; } //Used to rerender LCV after adding items.
    
    [Parameter] public Action? OnCheckClicked { get; set; } //Used in Import for overriding the default behavior.

    [Parameter] public bool ClearSelectedOnConfirm { get; set; } = true; //Used in Import.
    
    public Guid SelectedItem { get; set; } = Guid.Empty; //Used in LCV when viewing a single item.
    
    protected override void OnInitialized() => RefreshData();

    private void RefreshData()
    {
        Albums = C.GetCollectionsTable(true, false, false);
        Folders = C.GetCollectionsTable(false, true, false);
        checkedAlbums = (from album in Albums select new bool()).ToList();
        checkedFolders = (from folder in Folders select new bool()).ToList();
        CheckedFolderIndex = -1;
    }

    private void CloseBtnClick()
    {
        Disable();
        ClearSelectedCollections();
    }

    private void ClearSelected()
    {
        SelectedItems.Clear();
        Disable();
        Rerender?.Invoke();
    }

    private void ClearAlbumChecks() => checkedAlbums = checkedAlbums.Select(_ => false).ToList();

    private void ClearFolderChecks() => checkedFolders = checkedFolders.Select(_ => false).ToList();

    private void ClearSelectedCollections()
    {
        ClearAlbumChecks();
        ClearFolderChecks();
    }
    
    private void AlbumClicked(int index)
    {
        ClearFolderChecks();
        CheckedFolderIndex = -1;
        checkedAlbums[index] = !checkedAlbums[index];
    }

    private void FolderClicked(int index)
    {
        ClearSelectedCollections();
        CheckedFolderIndex = index;
        checkedFolders[index] = true;
    }
    
    ///Selects the new collection that was just created.
    private async void SelectNewCollection()
    {
        RefreshData();

        await InvokeAsync(StateHasChanged); //https://stackoverflow.com/questions/56477829/how-to-fix-the-current-thread-is-not-associated-with-the-renderers-synchroniza

        int newestAlbumIndex = Albums.FindIndex(a => a.Name == collectionCreator.NewCollectionName);
        if (newestAlbumIndex != -1)
        {
            checkedAlbums[newestAlbumIndex] = true;
        }
        else
        {
            int newestFolderIndex = Folders.FindIndex(f => f.Name == collectionCreator.NewCollectionName);
            if (newestFolderIndex == -1) return;
            CheckedFolderIndex = newestFolderIndex;
            checkedFolders[newestFolderIndex] = true;
        }
    }

    ///Add item(s) to album(s) or folder selected.
    private async void ConfirmBtnClick()
    {
        if (OnCheckClicked != null)
        {
            OnCheckClicked.Invoke();
        }
        else
        {
            if (CheckedFolderIndex != -1) //If a folder is selected this won't be -1
            {
                if (SelectedItem != Guid.Empty)
                {
                    await C.AddToCollectionAsync(Folders[CheckedFolderIndex].Id, SelectedItem);
                }
                else
                {
                    foreach (Guid item in SelectedItems)
                        await C.AddToCollectionAsync(Folders[CheckedFolderIndex].Id, item);
                }
            }
            else //Adding to album(s).
            {
                for (int c = 0; c < checkedAlbums.Count; c++)
                {
                    if (!checkedAlbums[c]) continue;

                    if (SelectedItem != Guid.Empty)
                    {
                        await C.AddToCollectionAsync(Albums[c].Id, SelectedItem);
                    }
                    else
                    {
                        foreach (Guid item in SelectedItems)
                            await C.AddToCollectionAsync(Albums[c].Id, item);
                    }
                }
            }
        }

        //Save this selection of albums/folder for next time.
        PreviousSelectionBtnClick(true);

        CloseBtnClick();

        if (ClearSelectedOnConfirm)
            ClearSelected();
    }

    private void PreviousSelectionBtnClick(bool save)
    {
        MouseEventArgs mouseEventArgs = new() {CtrlKey = save};
        SaveBtnClick(0, mouseEventArgs);
    }

    ///Handles saving and restoring of groups of saved Collections.
    private void SaveBtnClick(int id, MouseEventArgs mouseEventArgs)
    {
        string filePath = Path.Join(S.FolderPath, $"slot{id}.tmp");
        if (mouseEventArgs.CtrlKey) //Save/overwrite selection.
        {
            SaveSelectionToDisk();
        }
        else if (File.Exists(filePath)) //Load and apply existing one.
        {
            bool rewrite = false; //If it encountered an ID that no longer exists in DB and it should rewrite the tmp file to remove it/them.
            
            ClearSelectedCollections();
            
            string[] input = File.ReadAllLines(filePath);
            if (input[0] == "F")
            {
                CheckedFolderIndex = FindIndex(checkedFolders, Folders, input[1]);
                if (CheckedFolderIndex == -1) rewrite = true;
                else checkedFolders[CheckedFolderIndex] = true;
            }
            else if (input[0] == "A")
            {
                for (int i = 1; i < input.Length; i++)
                {
                    int index = FindIndex(checkedAlbums, Albums, input[i]);
                    if (index == -1)
                    {
                        rewrite = true;
                        continue;
                    }
                    checkedAlbums[index] = true;
                }
            }
            
            if (rewrite) SaveSelectionToDisk();
        }
        else
        {
            ClearSelectedCollections();
        }
        StateHasChanged();
        return;

        void SaveSelectionToDisk()
        {
            if (checkedFolders.Any(b => b))
                File.WriteAllText(filePath, $"F\n{Folders[CheckedFolderIndex].Id}");
            else
            {
                File.WriteAllText(filePath, "A\n");
                for (int i = 0; i < checkedAlbums.Count; i++)
                {
                    if (checkedAlbums[i])
                        File.AppendAllText(filePath, $"{Albums[i].Id}\n");
                }
            }
        }
        
        //From checkedAlbums or checkedFolders, figure out the index for it in checkedAlbums.
        int FindIndex(List<bool> checkedList, List<Collection> collections, string albumID)
        {
            int parsedID = Int32.Parse(albumID);
            for (int i = 0; i < checkedList.Count; i++)
                if (collections[i].Id == parsedID)
                    return i;
            
            return -1;
        }
    }
}