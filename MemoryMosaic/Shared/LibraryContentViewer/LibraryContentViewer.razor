@*
Used on a lot of different pages like Home, Starred, CollectionView, Memories, Trash, etc. for displaying items in user's library, optionally grouping items together.
Content is dynamically loaded in small chunks as they scroll up or down the page.
Items can be selected, and depending on the page, different options may be applied to them, such as (un)starring, deleting, changing what collection(s) they are a part of, etc.
*@
@inherits Component
@inject NavigationManager navigationManager
@using System.IO.Compression

<KeyboardShortcuts Esc="@ClearChecks" CtrlShiftMinus="@(() => ViewMode++)" CtrlShiftPlus="@(() => ViewMode--)"/>

<header style="visibility: @(SelectedIndexes.Count > 0 ? "visible" : "hidden")">
	<IconButton Icon="close" OnClick="@ClearChecks"/>
	<span>@SelectedIndexes.Count&nbsp;&nbsp;Selected</span>
	
	<div id="buttons">
		<IconButton Icon="file_download" OnClick="@DownloadButtonClick" Title="Download Selected"/>
		<IconButton Icon="collections" Title="Toggle CollectionSelector"/>
		<IconButton Icon="star_outline" OnClick="@(() => StarPrompt.Enable())" Title="Add or Remove Stars From Selected"/>
		<IconButton Icon="trash" Title="Delete Selected"/>
	</div>
</header>

<div id="top-load-div"></div>
<main>
@{
	int index = 0;
	if (viewMode == ViewMode.None)
	{
		<div class="ungrouped">
			@foreach (MediaRow item in Content)
			{
				<Thumbnail @key="@item" Item="@item" Parent="@this" Index="@index" OnClick="@OnThumbnailClick"/>
				index++;
			}
		</div>
	}
	else
	{
		foreach (var group in Content.GroupBy(SortFunction))
		{
			<div class="group">
				@if (group.Count() > 1)
				{
					int start = index;
					int end = start + group.Count() - 1;
					bool selectThisGroup = false;

					for (int i = start; i <= end; i++)
					{
						if (!SelectedIndexes.Contains(i))
						{
							selectThisGroup = true;
							break;
						}
					}
					<Checkbox OnChange="@(() => ChangeRangeState(start, end, selectThisGroup))" Input="@(!selectThisGroup)" Label="@FormatDateTaken(group.First().dateTaken)"/>
				}
				else
				{
					<span>@FormatDateTaken(group.First().dateTaken)</span>
				}
				<div class="thumbnails">
					@foreach (MediaRow item in group)
					{
						<Thumbnail @key="@item" Item="@item" Parent="@this" Index="@index" OnClick="@OnThumbnailClick"/>
						index++;
					}
				</div>
			</div>
		}
	}
}
</main>
<div id="bottom-load-div"></div>

<TwoChoiceInput @ref="@StarPrompt" YesBtnIcon="star" YesBtnText="Add" NoBtnIcon="star_outline" NoBtnText="Remove" YesBtnClick="@(() => UpdateStars(true))" NoBtnClick="@(() => UpdateStars(false))" Message="@(SelectedIndexes.Count > 1 ? "Add or remove stars for selected items?" : "Add or remove star for selected item?")"/>

<ProgressPopUp @ref="@downloadPopUp" Message="Preparing Zip..."/>

@code {
	[Parameter]
	public ViewMode DefaultViewMode { get; set; } = ViewMode.Day;
}

@code {
	private List<MediaRow> Content { get; set; } = null!;
	
	public HashSet<int> SelectedIndexes { get; private set; } = null!;
	private int lastCheckedIndex;

	private IEnumerable<Guid> SelectedIds => SelectedIndexes.Select(index => Content[index].uuid);

	private TwoChoiceInput StarPrompt = null!;
	
	private ProgressPopUp downloadPopUp = null!;

	private ViewMode viewMode;
	private ViewMode ViewMode
	{
		get => viewMode;
		set
		{
			int intValue = (int) value;
			if (intValue is < 0 or > 3) return;
			viewMode = value;
			StateHasChanged();
		}
	}
	
	private Func<MediaRow, dynamic?> SortFunction => ViewMode switch 
	{
		ViewMode.None => row => row.dateTaken?.Date,
		ViewMode.Day => row => row.dateTaken?.Date,
		ViewMode.Month => row => new {row.dateTaken?.Month, row.dateTaken?.Year},
		ViewMode.Year => row => row.dateTaken?.Year,
		_ => throw new ArgumentOutOfRangeException()
	};
	
	protected override async Task OnInitializedAsync()
	{
		SelectedIndexes = new HashSet<int>();
		Content = C.LoadEntireMediaTable();
		ViewMode = DefaultViewMode;
	}
}

@functions {
	public void Rerender() => StateHasChanged();

	private void ChangeRangeState(int startIndex, int endIndex, bool select)
	{
		int increment = startIndex < endIndex ? 1 : -1;

		for (int i = startIndex; i != endIndex + increment; i += increment)
		{
			if (select) SelectedIndexes.Add(i);
			else SelectedIndexes.Remove(i);
		}

		StateHasChanged();
	}
	
	private string FormatDateTaken(DateTime? dateTaken)
	{
		if (dateTaken == null) return "No Date Taken";
		if (ViewMode == ViewMode.None) return "";

		bool thisYear = dateTaken.Value.Year == DateTime.Now.Year;
		string formatString = ViewMode switch
		{
			ViewMode.Day => thisYear ? "ddd, MMM d" : "ddd, MMM d, yyyy",
			ViewMode.Month => thisYear ? "MMMM" : "MMMM yyyy",
			ViewMode.Year => "yyyy",
			_ => ""
		};

		return dateTaken.Value.ToString(formatString);
	}

	private void OnThumbnailClick(MouseEventArgs eventArgs, int index)
	{
		if (eventArgs.ShiftKey)
			ChangeRangeState(lastCheckedIndex, index, true);
		else
			lastCheckedIndex = index;
	}
	
	private void ClearChecks()
	{
		SelectedIndexes.Clear();
		StateHasChanged();
	}

	private void UpdateStars(bool starred)
	{
		C.UpdateStarred(SelectedIds, starred);
		StarPrompt.Disable();
		
		foreach (MediaRow item in Content.Where(item => SelectedIds.Contains(item.uuid)))
			item.starred = starred;

		ClearChecks();
	}
	
	private async void DownloadButtonClick()
	{
		if (SelectedIndexes.Count == 0) return;

		downloadPopUp.Enable();
		await InvokeAsync(StateHasChanged);
		await Task.Delay(0);
		await Task.Delay(1);

		string zipFolderPath = Path.Combine(S.tmpFolderPath, $"Download {Guid.NewGuid()}");
		Directory.CreateDirectory(zipFolderPath);

		foreach (string shortPath in from media in Content where SelectedIds.Contains(media.uuid) select media.path)
		{
			string fullPath = Path.Combine(S.libFolderPath, shortPath);
			string destPath = Path.Combine(zipFolderPath, Path.GetFileName(shortPath));
			File.Copy(fullPath, destPath);
		}
		
		ClearChecks();

		string zipFilename = $"MM Download {DateTime.Now:M-d-yyyy h;mm;ss tt}.zip";
		string zipFilePath = Path.Combine(S.tmpFolderPath, zipFilename);
		ZipFile.CreateFromDirectory(zipFolderPath, zipFilePath, CompressionLevel.Fastest, false);

		downloadPopUp.Disable();
		await InvokeAsync(StateHasChanged);

		Directory.Delete(zipFolderPath, true);//Not needed after it's zipped.

		navigationManager.NavigateTo($"mm_tmp/{zipFilename}", true);
	}
}
