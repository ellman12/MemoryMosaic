@page "/import"
@using System.Text
@using MemoryMosaic.DataStructures

<title>Import - MemoryMosaic</title>
<link href="css/Pages/Import.css" rel="stylesheet"/>
<link href="css/Components/Import/ImportItemDisplay.css" rel="stylesheet"/>

<header>
	@if (SelectedItems.Count > 0)
	{
		<IconButton Icon="close" OnClick="@ClearChecks"/>
		<span>@SelectedItems.Count&nbsp;&nbsp;Selected</span>
	}

	@{
		string addBtnMsg;
		if (SelectedItems.Count == 0 || SelectedItems.Count == importItems.Count)
			addBtnMsg = "Add All";
		else if (SelectedItems.Count == 1)
			addBtnMsg = "Add 1 Item";
		else
			addBtnMsg = $"Add {SelectedItems.Count} Items";
		<IconTextButton Icon="library_add" Text="@addBtnMsg" OnClick="@AddItems"/>
	}
</header>

<main>
	@for (int i = 0; i < importItems.Count; i++)
	{
		<ImportItemDisplay Import="@this" ImportItem="@importItems[i]" Index="@i"/>
	}
</main>

<CollectionSelector @ref="@cs" OnCheckClicked="@UpdateCollections" SelectedItems="@SelectedItems" ClearSelectedOnConfirm="false"/>

@* <FullscreenViewer @ref="@fv" T="@Media" CollectionSelector="@cs" RerenderParent="@StateHasChanged" Content="" DisplayItemType="true"/> *@

<KeyboardShortcuts AltS="@TogglePathWidth" Esc="@ClearChecks"/>

@code {
	private CollectionSelector cs = null!;

	private FullscreenViewer<Media> fv = null!;
}

@code {
	public HashSet<Guid> SelectedItems { get; } = new();

	public string PathWidth { get; private set; } = "short";

	public int LastCheckedIndex { get; set; }

	public int MinYear { get; private set; } = 2000;
	public int MaxYear { get; private set; } = DateTime.Now.Year;

	private bool finishedLoading;

	private List<LibraryItem> libraryCache = null!, filesWithSameName = new(), filesWithSimilarName = new();

	private readonly List<ImportItem> importItems = new();
}

@functions {
	protected override async Task OnInitializedAsync()
	{
		L.LogLine($"Begin Import.{nameof(OnInitialized)}", LogLevel.Info);

		Parallel.ForEach(F.GetSupportedFiles(S.ImportFolderPath), (absPath, _) =>
		{
			ImportItem importFile = new(absPath.Replace('\\', '/'));
			importItems.Add(importFile);
		});

		L.LogLine($"Finish Import.{nameof(OnInitialized)}", LogLevel.Info);
	}

	public void Rerender() => StateHasChanged();

	private void ClearChecks()
	{
		SelectedItems.Clear();
		Rerender();
	}

	private void TogglePathWidth()
	{
		PathWidth = PathWidth == "short" ? "full" : "short";
		Rerender();
	}
	
	public void ChangeRangeState(int startIndex, int endIndex)
	{
		int increment = startIndex < endIndex ? 1 : -1;

		for (int i = startIndex; i != endIndex + increment; i += increment)
			SelectedItems.Add(importItems[i].Id);

		StateHasChanged();
	}

	private async void AddItems()
	{
		IEnumerable<ImportItem> items = SelectedItems.Count == 0 || SelectedItems.Count == importItems.Count ? importItems : importItems.Where(item => SelectedItems.Contains(item.Id));

		foreach (ImportItem item in items.ToList())
		{
			DateTime? dateTaken = item.DateTakenSource switch
			{
				DateTakenSource.Metadata => item.MetadataDateTaken,
				DateTakenSource.Filename => item.FilenameDateTaken,
				DateTakenSource.Custom => item.CustomDateTaken,
				DateTakenSource.None => null,
				_ => throw new ArgumentOutOfRangeException()
			};
			
			await C.InsertItem(item, dateTaken);

			if (item.Collections != null)
			{
				foreach (var collection in item.Collections)
					await C.AddToCollectionAsync(collection.Id, item.Id);
			}
			
			string destFolder = C.CreateFullDateFolderPath(dateTaken);
			Directory.CreateDirectory(destFolder);
			string destPath = C.CreateFullPath(dateTaken, item.OriginalFilename + item.Extension);
			File.Move(item.AbsolutePath, destPath);

			await Task.Run(() => D.UpdateDateTaken(destPath, dateTaken));
		}
		
		if (SelectedItems.Count > 0)
            importItems.RemoveAll(file => SelectedItems.Contains(file.Id));
        else
			importItems.Clear();

        ClearChecks();
	}
	
	private void UpdateCollections()
	{
		foreach (ImportItem item in importItems.Where(item => SelectedItems.Contains(item.Id)))
		{
			item.Collections ??= new HashSet<Collection>();

			if (cs.SelectedFolderId != -1)
			{
				item.Collections.Clear();
				item.Collections.Add(cs.Folders.Find(folder => folder.Id == cs.SelectedFolderId) ?? throw new NullReferenceException());
			}
			else
			{
				item.Collections.RemoveWhere(folder => cs.Folders.Contains(folder));
				item.Collections.UnionWith(cs.Albums.Where(album => cs.SelectedAlbums.Contains(album.Id)));
			}
		}

		StateHasChanged();
	}
}